"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", { value: true });
var PT = require("prop-types");
var React = require("react");
var classNames = require("classnames");
var nav_frontend_ikoner_assets_1 = require("nav-frontend-ikoner-assets");
require("nav-frontend-spinner-style");
var cls = function cls(className, storrelse) {
    return classNames('spinner', className, _defineProperty({}, "spinner--" + storrelse.toLowerCase(), !!storrelse));
};

var NavFrontendSpinner = function (_React$Component) {
    _inherits(NavFrontendSpinner, _React$Component);

    function NavFrontendSpinner() {
        _classCallCheck(this, NavFrontendSpinner);

        return _possibleConstructorReturn(this, (NavFrontendSpinner.__proto__ || Object.getPrototypeOf(NavFrontendSpinner)).apply(this, arguments));
    }

    _createClass(NavFrontendSpinner, [{
        key: "render",
        value: function render() {
            var _props = this.props,
                negativ = _props.negativ,
                stroke = _props.stroke,
                transparent = _props.transparent,
                type = _props.type,
                className = _props.className,
                props = _objectWithoutProperties(_props, ["negativ", "stroke", "transparent", "type", "className"]);

            var ikon = stroke ? 'spinner-stroke' : 'spinner';
            ikon = negativ ? ikon + "-negativ" : ikon;
            ikon = transparent ? 'spinner-transparent' : ikon;
            return React.createElement(nav_frontend_ikoner_assets_1.default, Object.assign({ kind: ikon, className: cls(className, type) }, props));
        }
    }]);

    return NavFrontendSpinner;
}(React.Component);

NavFrontendSpinner.propTypes = {
    negativ: PT.bool,
    stroke: PT.bool,
    transparent: PT.bool,
    type: PT.oneOf(['XXS', 'XS', 'S', 'M', 'L', 'XL', 'XXL', 'XXXL']),
    className: PT.string,
    'aria-label': PT.string
};
NavFrontendSpinner.defaultProps = {
    'aria-label': 'Laster innhold',
    negativ: false,
    stroke: false,
    transparent: false,
    type: 'M',
    className: undefined
};
exports.default = NavFrontendSpinner;
NavFrontendSpinner.__docgenInfo = {"description":"","displayName":"NavFrontendSpinner","props":{"negativ":{"defaultValue":null,"description":"-","name":"negativ","required":false,"type":{"name":"boolean"}},"stroke":{"defaultValue":null,"description":"Border rundt spinneren","name":"stroke","required":false,"type":{"name":"boolean"}},"transparent":{"defaultValue":null,"description":"Gjennomsiktig bakgrunn","name":"transparent","required":false,"type":{"name":"boolean"}},"className":{"defaultValue":null,"description":"Classname","name":"className","required":false,"type":{"name":"string"}},"aria-label":{"defaultValue":null,"description":"-","name":"aria-label","required":false,"type":{"name":"string"}}}}